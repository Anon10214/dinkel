/*
Package seed provides seeds used to decide behavior during query generation.

For example, a clause may decide to return a value if the seed returns
an even value. Else it decides to returns no value.
*/
package seed

import (
	"math/rand"
	"time"

	"github.com/sirupsen/logrus"
)

// A Seed has the GetByte function, which can be used by clauses to guide generation.
type Seed struct {
	underlyingSeedSource source
}

// GetByte returns the next byte of the seed's underlying source
func (s *Seed) GetByte() byte {
	return s.underlyingSeedSource.GetByte()
}

// GetByteString returns the string of bytes which have been generated
func (s *Seed) GetByteString() []byte {
	return s.underlyingSeedSource.GetByteString()
}

// A Source is used by a seed to get bytes
type source interface {
	GetByteString() []byte
	GetByte() byte
}

// wrapSeedSource takes in a source and returns a seed sourcing it
func wrapSeedSource(source source) *Seed {
	return &Seed{underlyingSeedSource: source}
}

// A randomByteString returns bytes randomly
type randomByteString struct {
	source          *rand.Rand
	generatedString []byte
}

func (r *randomByteString) GetByte() byte {
	generated := byte(r.source.Intn(2 << 8))
	r.generatedString = append(r.generatedString, generated)
	return generated
}

func (r randomByteString) GetByteString() []byte {
	return r.generatedString
}

// GetRandomByteString returns a seed returning randomly generated bytes.
func GetRandomByteString() *Seed {
	return wrapSeedSource(&randomByteString{
		source: rand.New(rand.NewSource(time.Now().UnixMilli())),
	})
}

// GetRandomByteStringWithSource returns a seed returning bytes
// which get read from the passed source.
func GetRandomByteStringWithSource(source rand.Rand) *Seed {
	return wrapSeedSource(&randomByteString{
		source: &source,
	})
}

// A pregeneratedByteString returns, given a byte slice, the contained elements in order.
//
// Useful for regenerating queries by passing it the previously generated byte string.
// If all elements of the byte slice have been returned, it starts generating bytes randomly
type pregeneratedByteString struct {
	generatedString []byte
	index           int
	overflow        randomByteString
}

func (p *pregeneratedByteString) GetByte() byte {
	if p.index == len(p.generatedString) {
		p.index++
		logrus.Info("PregeneratedByteString ran out of bytes, generating future bytes randomly")
		p.overflow = randomByteString{
			source: rand.New(rand.NewSource(time.Now().UnixMilli())),
		}
	}

	if p.index >= len(p.generatedString) {
		return p.overflow.GetByte()
	}
	p.index++

	return p.generatedString[p.index-1]
}

func (p pregeneratedByteString) GetByteString() []byte {
	return append(p.generatedString, p.overflow.GetByteString()...)
}

// GetPregeneratedByteString returns a seed which returns the bytes passed in the slice of bytes in order.
// If the passed slice is too short, it starts randomly generating future bytes after exhausting the slice of bytes.
func GetPregeneratedByteString(byteString []byte) *Seed {
	return wrapSeedSource(&pregeneratedByteString{
		generatedString: byteString,
	})
}
