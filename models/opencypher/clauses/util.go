package clauses

import (
	"strings"

	"github.com/Anon10214/dinkel/models/opencypher/config"
	"github.com/Anon10214/dinkel/models/opencypher/schema"
	"github.com/Anon10214/dinkel/seed"
	"github.com/Anon10214/dinkel/translator"
)

func generatePropertyType(seed *seed.Seed) schema.PropertyType {
	conf := config.GetConfig()
	for {
		// Generate a property type, excluding ANY_CONSTANT
		genType := schema.PropertyType(seed.GetRandomIntn(12) + 1)
		// Make sure the property type isn't disallowed
		var isDisallowed bool
		for _, ignored := range conf.DisallowedPropertyTypes {
			if ignored == genType {
				isDisallowed = true
				break
			}
		}
		if !isDisallowed {
			return genType
		}
	}
}

func addVariableToSchema(s *schema.Schema, name string, Conf schema.ExpressionConfig) {
	var mask int
	if Conf.IsList {
		mask |= schema.ListMask
	}
	if Conf.MustBeNonNull {
		mask |= schema.NullableMask
	}

	if Conf.TargetType == schema.PropertyValue {
		s.AddPropertyVariable(schema.PropertyVariable{
			Name: name,
			Type: Conf.PropertyType | schema.PropertyType(mask),
		})
	} else if Conf.TargetType == schema.StructuralValue {
		s.AddStructuralVariable(schema.StructuralVariable{
			Name:       name,
			Type:       Conf.StructuralType | schema.StructuralType(mask),
			LikelyNull: !Conf.MustBeNonNull,
		})
	}
}

func generateExpressionConf(seed *seed.Seed) schema.ExpressionConfig {
	targetType := schema.PropertyValue
	if seed.RandomBoolean() {
		targetType = schema.StructuralValue
	}
	config := schema.ExpressionConfig{
		IsList:               seed.RandomBoolean(),
		TargetType:           targetType,
		PropertyType:         generatePropertyType(seed),
		StructuralType:       generateStructuralType(seed),
		IsConstantExpression: false,
	}

	if targetType == schema.StructuralValue {
		config.MustBeNonNull = false
	}

	return config
}

// Populates the variables to return fields of the schema
func populateVariablesToReturn(seed *seed.Seed, s *schema.Schema) {
	s.MustReturn = true
	// Ensure at least one value has to be returned
	for len(s.PropertyVariablesToReturn)+len(s.StructuralVariablesToReturn) == 0 {
		// Force return of geometrically distributed amounts of property variables
		for seed.RandomBoolean() {
			s.PropertyVariablesToReturn = append(s.PropertyVariablesToReturn, schema.PropertyVariable{
				Name: generateUniqueName(seed, s),
				Type: generatePropertyType(seed),
			})
		}
		// Force return of geometrically distributed amounts of structural variables
		for seed.RandomBoolean() {
			s.StructuralVariablesToReturn = append(s.StructuralVariablesToReturn, schema.StructuralVariable{
				Name: generateUniqueName(seed, s),
				Type: generateStructuralType(seed),
			})
		}
	}
}

// Returns the property with the probability provided, or the empty clause otherwise
func optionalClauseWithProbability(seed *seed.Seed, clause translator.Clause, probability float64) translator.Clause {
	if seed.BooleanWithProbability(probability) {
		return clause
	}
	return &EmptyClause{}
}

// Returns the property with probability 0.5, or the empty clause otherwise
func optionalClause(seed *seed.Seed, clause translator.Clause) translator.Clause {
	return optionalClauseWithProbability(seed, clause, 0.5)
}

type relationshipDirection int

const (
	// Left indicates a relationship direction from right to left
	Left relationshipDirection = -1
	// None indicates no relationship
	None relationshipDirection = 0
	// Right indicates a relationship direction from left to right
	Right relationshipDirection = 1
	// Any indicates a unidirectional relationship direction
	Any relationshipDirection = 2
)

// Constants for names
var (
	allowedStartingCharacters []rune = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_")
	allowedCharacters         []rune = append([]rune("0123456789"), allowedStartingCharacters...)
)

// Returns a random rune from the provided array using the index generated by the seed
func getRandomCharacter(seed *seed.Seed, runes []rune) rune {
	return runes[seed.GetRandomIntn(len(runes))]
}

// Generates a legal Cypher variable name
func generateName(seed *seed.Seed) string {
	// Decide how long the name should be (between 1 and 10 characters)
	stringLength := seed.GetRandomIntn(10) + 1

	// Generate the name
	var generatedString strings.Builder
	generatedString.Grow(stringLength)
	generatedString.WriteRune(getRandomCharacter(seed, allowedStartingCharacters))
	for i := 0; i < stringLength-1; i++ {
		generatedString.WriteRune(getRandomCharacter(seed, allowedCharacters))
	}
	return generatedString.String()
}

func generateUniqueName(seed *seed.Seed, s *schema.Schema) string {
	var generatedString string
	for {
		generatedString = generateName(seed)
		// Ensure the name is unique
		if _, found := (*s.UsedNames)[generatedString]; !found {
			(*s.UsedNames)[generatedString] = true
			break
		}
	}

	return generatedString
}

// Generates a unique name and adds it to necessary maps in the schema by type
func generateStructureName(seed *seed.Seed, s *schema.Schema, varType schema.StructuralType, likelyNull bool) string {
	name := generateUniqueName(seed, s)
	variable := schema.StructuralVariable{
		Name:       name,
		Type:       varType,
		LikelyNull: likelyNull,
	}
	s.AddStructuralVariable(variable)
	return name
}

func generatePropertyName(seed *seed.Seed, s *schema.Schema, varType schema.PropertyType) string {
	name := generateUniqueName(seed, s)
	variable := schema.Property{
		Name: name,
		Type: varType,
	}
	s.AddProperty(variable)
	return name
}

func generateStructuralType(seed *seed.Seed) schema.StructuralType {
	return schema.StructuralType(seed.GetRandomIntn(4))
}

func decideOnLabelMatchType(seed *seed.Seed, s *schema.Schema) {

	// Set UseNewLabelMatchType if not yet set
	if s.UseNewLabelMatchType == nil {
		useNewMatchType := false
		// UseNewMatchType is always false if in subquery
		if !s.IsInSubquery && seed.RandomBoolean() {
			useNewMatchType = true
		}
		s.UseNewLabelMatchType = &useNewMatchType
	}

}
